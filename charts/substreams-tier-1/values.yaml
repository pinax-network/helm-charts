# Default values for substreams tier 1.
# This is a YAML-formatted file.

serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

alertManager:
  # -- Set to true if AlertManager integration is enabled
  enabled: false
  # -- The namespace where head_block_time_drift metrics are collected
  namespace: {}
  # -- Threshold in seconds for triggering a warning alert for head block time drift
  warnBlockTime: 30
  # -- Threshold in seconds for triggering a critical alert for head block time drift
  critBlockTime: 90


# -- Image configuration for substreams tier 2
image:
  # -- The repository where the Docker image is located.
  repository: ghcr.io/streamingfast/firehose-ethereum
  
  # -- The pull policy for the Docker image.
  # Valid options are "Always", "IfNotPresent", and "Never".
  pullPolicy: IfNotPresent
  
  # -- The tag of the Docker image to use.
  # If not set, the default tag will be used.
  tag: "v2.5.1"

blockChain:
  # -- The name of the blockchain network. Possible values could be "mainnet", "testnet", "devnet", etc.
  network: {}
  
  # -- The version of the blocks. Specify the version you are using, e.g., "1.0.0", "2.1.3", "v1", etc.
  blocksVersion: {}

  # -- The type of blockchain component. Possible values could be "cl, "consensus-layer, "el, "execution-layer", etc.
  type: {}

# -- Overrides the name of the chart.
# If not set, the name will be derived from the chart name.
nameOverride: ""

# -- Overrides the full name of the chart.
# If not set, the full name will be derived from the release name and the chart name.
fullnameOverride: ""

resources:
  enabled: false
  requests:
    # -- Specifies the CPU resource request for the container.
    # CPU resource requests are measured in units of cores.
    # Examples: "250m" for 0.25 cores, "1" for 1 core.
    cpu: {}

    # -- Specifies the memory resource request for the container.
    # Memory resource requests are measured in bytes.
    # Examples: "256Mi" for 256 mebibytes, "1Gi" for 1 gibibyte.
    memory: {}

  limits:
    # -- Specifies the CPU resource limit for the container.
    # CPU resource limits are measured in units of cores.
    # Examples: "500m" for 0.5 cores, "2" for 2 cores.
    cpu: {}

    # -- Specifies the memory resource limit for the container.
    # Memory resource limits are measured in bytes.
    # Examples: "512Mi" for 512 mebibytes, "2Gi" for 2 gibibytes.
    memory: {}


substreams:

  # -- Configuration for the Substreams component.
  config: |
    # -- Sets the verbosity level of the logging. 0 means least verbose.
    log-verbosity: 0
    
    # -- Determines if logs should be written to a file. If false, logs will be written to stdout.
    log-to-file: false
    
    # -- Configuration for the common authentication plugin.
    common-auth-plugin: {}
    
    # -- Configuration for the common metering plugin.
    common-metering-plugin: {}
    
    # -- Address for live block data.
    common-live-blocks-addr: {}
    
    # -- URL for the merged blocks store.
    common-merged-blocks-store-url: {}
    
    # -- URL for the one block store.
    common-one-block-store-url: {}
    
    # -- URL for the forked blocks store.
    common-forked-blocks-store-url: {}
    
    # -- Delay before shutting down the system after a shutdown signal is received.
    common-system-shutdown-signal-delay: 10s
    
    # -- Percentage of memory limit that should trigger auto memory management.
    common-auto-mem-limit-percent: 90
    
    # -- RPC endpoints for Substreams.
    substreams-rpc-endpoints: {}
    
    # -- URL for the Substreams state store.
    substreams-state-store-url: {}
    
    # -- Address for the Substreams Tier 1 gRPC listener.
    substreams-tier1-grpc-listen-addr: :9000
    
    # -- Endpoint for Substreams Tier 1 subrequests.
    substreams-tier1-subrequests-endpoint: {}

  # Configuration for the service monitor
  serviceMonitor:
    # -- Enable or disable the service monitor
    enabled: true # 
    # -- Interval at which Prometheus scrapes metrics
    interval: 30s 
    # -- Timeout for the scrape request
    scrapeTimeout: 10s 

  # -- Pull secrets required to fetch the Image
  imagePullSecrets: {}

  autoscaling:
    # -- Specifies whether the Horizontal Pod Autoscaler is enabled
    enabled: true

    # -- Specifies the minimum number of replicas that the autoscaler can scale down to.
    minReplicas: 1
    
    # -- Specifies the maximum number of replicas that the autoscaler can scale up to.
    maxReplicas: 5
    
    # -- Specifies the target average CPU utilization (represented as a percentage of requested CPU) across all replicas.
    # The autoscaler will adjust the number of replicas to maintain this average utilization.
    targetCPUUtilizationPercentage: 80
    
    # -- Specifies the target average memory utilization (represented as a percentage of requested memory) across all replicas.
    # The autoscaler will adjust the number of replicas to maintain this average utilization.
    targetMemoryUtilizationPercentage: 80



  service:
    # -- Specifies the type of the Kubernetes service.
    # Valid options are "ClusterIP", "NodePort", "LoadBalancer", and "ExternalName".
    type: ClusterIP
    
    # -- Specifies the IP family policy for the service.
    # Valid options are "SingleStack", "PreferDualStack", and "RequireDualStack".
    ipFamilyPolicy: {}
    
    # -- Specifies the cluster IP address of the service.
    # If not specified, a cluster IP will be automatically assigned.
    clusterIP: {}
    
    ports:
      # -- Specifies the port for the Substreams GRPC interface.
      # This port will be exposed by the service.
      grpc: 9000
      
      # -- Specifies the port for the metrics interface.
      # This port will be exposed by the service.
      metrics: 9102


  # -- Define custom aliases for preconfigured commands in your environment.
  # This allows you to create shorthand commands for frequently used operations,
  # enhancing efficiency and reducing the need for repetitive typing.
  env: {}

  
  # -- Specify additional command-line arguments to pass to the `tier-2` component.
  # These arguments can be used to override default settings or provide additional
  # configurations that are not covered by the standard configuration options.
  extraArgs: {}

  # Increasing the grace termination period prevents Kubernetes
  # from killing the node process prematurely. Premature shutdown
  # can lead to data integrity issues
  # -- Amount of time to wait before force-killing the process
  terminationGracePeriodSeconds: 10

  # -- Annotations for the `Pod`
  podAnnotations: {}

  # -- Pod-wide security context
  podSecurityContext: {}

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    #   ephemeral-storage: 100Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
      #   ephemeral-storage: 100Mi
  
  # -- Node selection constraints for pod scheduling.
  # Allows you to specify a map of key-value pairs to target specific nodes.
  nodeSelector: {}
  
  # -- Tolerations for pod scheduling.
  # Allows the pod to be scheduled on nodes with matching taints.
  # Example:
  # tolerations:
  #   - key: "key1"
  #     operator: "Exists"
  #     effect: "NoSchedule"
  tolerations: {}
  
  # -- Affinity rules for pod scheduling.
  # Defines rules for preferred or required node and pod selection.
  # Example:
  # affinity:
  #   nodeAffinity:
  #     requiredDuringSchedulingIgnoredDuringExecution:
  #       nodeSelectorTerms:
  #         - matchExpressions:
  #             - key: "key1"
  #               operator: "In"
  #               values:
  #                 - "value1"
  affinity: {}
